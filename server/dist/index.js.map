{"version":3,"sources":["../src/index.ts","../../shared/src/Tile.ts","../../shared/src/BoardTile.ts","../../shared/src/Constants.ts","../../shared/src/Board.ts","../../shared/src/Player.ts","../../shared/src/Utils.ts","../../shared/src/Bag.ts","../../shared/src/SharedGame.ts","../src/gameLogic.ts","../src/onlineGameManager.ts","../src/dawg/units.ts","../src/dawg/wrapper.ts","../src/dawg/dawgs.ts","../src/Dictionary.ts"],"sourcesContent":["import express from 'express';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport { dirname } from 'path';\nimport http from 'http';\nimport { Server } from 'socket.io';\nimport { onlineGameManager, createNewGame, checkGameId } from './onlineGameManager.js';\nimport cors from 'cors'; // Import cors\nimport Dictionary from './Dictionary.js';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\nconst app = express();\nconst port = process.env.PORT || 8080; // Get port from env var, default to 8080\n\nasync function initializeServer() {\n    const dictionary = new Dictionary();\n    await dictionary.init(path.join(__dirname, '..', '..', 'client', 'public'));\n\n    const server = http.createServer(app);\n    const io = new Server(server, {\n        cors: {\n            origin: \"*\", // Allow requests from any origin\n            methods: [\"GET\", \"POST\"], // Allow these HTTP methods\n        }\n    });\n    \n    app.use(cors()); // Enable CORS for all routes\n    app.use(express.json());\n    onlineGameManager(io, dictionary);\n\n    createNewGame(dictionary, \"test\");\n\n    app.post('/createGame', (req, res) => {\n        try {\n            const gameId = createNewGame(dictionary, null);\n            res.json({ gameId: gameId }); // Send the game ID back to the client\n        } catch (error) {\n            console.error(\"Error creating game:\", error);\n            res.status(500).json({ error: \"Failed to create game\" });\n        }\n    });\n\n    app.post('/gameExists', (req, res) => {\n        try {\n            const gameId = req.body.gameId; // Get the word from the request body\n            if (!gameId) {\n                return res.status(400).json({ error: \"gameId is required\" });\n            }\n\n            const gameExists = checkGameId(gameId);\n\n            res.json({ gameId: gameId, gameExists: gameExists });\n\n        } catch (error) {\n            console.error(\"Error checking gameId:\", error);\n            res.status(500).json({ error: \"Failed to check gameId\" });\n        }\n    });\n\n    app.post('/checkWord', (req, res) => {\n        try {\n            //console.log(\"checkWord\", req.body)\n            const word = req.body.word; // Get the word from the request body\n            if (!word) {\n                return res.status(400).json({ error: \"Word is required\" });\n            }\n\n            const isValid = dictionary.contains(word); // Check the word using the dictionary\n\n            console.log(`Checked word: ${word}, Is Valid: ${isValid}`);\n            res.json({ word: word, isValid: isValid }); // Send the result back\n\n        } catch (error) {\n            console.error(\"Error checking word:\", error);\n            res.status(500).json({ error: \"Failed to check word\" });\n        }\n    });\n\n    // Serve static files from the client directories\n    app.use(express.static(path.join(__dirname, '../../client/public/')));\n\n    // Catch-all route to serve index.html for SPA routing\n    app.get('*', (req, res) => {\n        console.log(\"request received\");\n        res.sendFile(path.join(__dirname, '../../client/public/index.html'));\n    });\n\n    server.listen(port, () => {\n        console.log(`Server is listening on port ${port}`);\n    });\n}\n\ninitializeServer();","\r\nlet counter = 0;\r\n\r\nexport type TilePlacement =\r\n{\r\n    tile: Tile;\r\n    r: number;\r\n    c: number;\r\n}\r\n\r\n/**\r\n * Represents a game tile\r\n */\r\nexport class Tile \r\n{\r\n    private readonly _letter: string;\r\n    private readonly _points: number;\r\n    private readonly _id    : number;\r\n  \r\n    constructor(letter: string, points: number) \r\n    {\r\n        this._letter = letter;\r\n        this._points = points;\r\n        this._id     = counter++;\r\n    }\r\n  \r\n    /**\r\n     * Returns the letter for this tile\r\n     */\r\n    get letter(): string \r\n    {\r\n        return this._letter;\r\n    }\r\n  \r\n    /**\r\n     * Returns the points for this tile\r\n     */\r\n    get points(): number \r\n    {\r\n        return this._points;\r\n    }\r\n\r\n    /**\r\n     * Returns the tile ID\r\n     */\r\n    get id(): number \r\n    {\r\n        return this._id;\r\n    }\r\n\r\n    /**\r\n     * Is this tile equal to another tile?\r\n     * @param other Other tile\r\n     * @returns True if the tiles are equal, false otherwise\r\n     */\r\n    public equals(other: Tile) : boolean { \r\n        return (\r\n            (this.letter == other.letter)\r\n            && (this.points == other.points)\r\n            && (this.id == other.id)\r\n        );\r\n    }\r\n\r\n    static fromJson(data: any): Tile {\r\n        const tile = new Tile(data._letter, data._points);\r\n        (tile as any)._id = data._id;\r\n        //counter = Math.max(counter, data._id + 1); // Ensure no duplicate IDs\r\n        return tile;\r\n    }\r\n}","import {Tile} from \"./Tile\";\r\n\r\nexport enum TileTypes {\r\n    Regular      = \"Regular\",\r\n    DoubleWord   = \"DoubleWord\",\r\n    DoubleLetter = \"DoubleLetter\",\r\n    TripleWord   = \"TripleWord\",\r\n    TripleLetter = \"TripleLetter\",\r\n    CenterTile   = \"CenterTile\"\r\n}\r\n\r\n/**\r\n * BoardTile class represents a board tile.\r\n * @class\r\n */\r\nexport default class BoardTile \r\n{\r\n    private readonly _row       : number;\r\n    private readonly _col       : number;\r\n    private          _tile      : Tile | null;\r\n    private          _type      : TileTypes;\r\n    private          _wordMul   : number;\r\n    private          _letterMul : number;\r\n  \r\n    /**\r\n     * Constructor for BoardTile class\r\n     * @param row - row number of the tile\r\n     * @param col - column number of the tile\r\n     */\r\n    constructor(row: number, col: number) \r\n    {\r\n        this._row = row;\r\n        this._col = col;\r\n        this._tile = null;\r\n        this._type = TileTypes.Regular;\r\n        this._wordMul = 1;\r\n        this._letterMul = 1;\r\n    }\r\n  \r\n    /**\r\n     * Getter for row property\r\n     * @returns row number of the tile\r\n     */\r\n    get row(): number \r\n    {\r\n        return this._row;\r\n    }\r\n  \r\n    /**\r\n     * Getter for col property\r\n     * @returns column number of the tile\r\n     */\r\n    get col(): number \r\n    {\r\n        return this._col;\r\n    }\r\n\r\n    /**\r\n     * Getter for tile property\r\n     * @returns Tile object or null if there is no tile on this board tile\r\n     */\r\n    get tile(): Tile | null\r\n    {\r\n        return this._tile;\r\n    }\r\n\r\n    /**\r\n     * Setter for tile property\r\n     * @param tile - Tile object to be set on this board tile\r\n     */\r\n    set tile(tile: Tile | null) \r\n    {\r\n        this._tile = tile;\r\n    }\r\n\r\n    /**\r\n     * Getter for type property\r\n     * @returns type of this board tile (Regular, DoubleLetter, TripleLetter, DoubleWord, TripleWord)\r\n     */\r\n    get type(): TileTypes\r\n    {\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * Setter for type property\r\n     * @param type - type of this board tile (Regular, DoubleLetter, TripleLetter, DoubleWord, TripleWord)\r\n     */\r\n    set type(type: TileTypes) \r\n    {\r\n        this._type = type;\r\n    }\r\n\r\n    /**\r\n     * Getter for wordMultiplier property - the score for a word placed on this tile is multiplied by this factor\r\n     * @returns word multiplier value of this board tile\r\n     */\r\n    get wordMultiplier(): number\r\n    {\r\n        return this._wordMul;\r\n    }\r\n\r\n    /**\r\n     * Setter for wordMultiplier property - the score for a word placed on this tile is multiplied by this factor\r\n     * @param value - word multiplier value to be set on this board tile\r\n     */\r\n    set wordMultiplier(value: number)\r\n    {\r\n        this._wordMul = value;\r\n    }\r\n\r\n    /**\r\n     * Getter for letterMultiplier property - the score for a letter placed on this tile is multiplied by this factor\r\n     * @returns letter multiplier value of this board tile (1 or 2 or 3)\r\n     */\r\n    get letterMultiplier(): number\r\n    {\r\n        return this._letterMul;\r\n    }\r\n\r\n    /**\r\n     * Setter for letterMultiplier property -  - the score for a letter placed on this tile is multiplied by this factor\r\n     * @param value - letter multiplier value to be set on this board tile (1 or 2 or 3)\r\n     */\r\n    set letterMultiplier(value: number)\r\n    {\r\n        this._letterMul = value;\r\n    }\r\n\r\n    /**\r\n     * Disables both word and letter multipliers by setting them to 1.\r\n     */\r\n    public disableMultiplier() : void\r\n    {\r\n        this._wordMul = 1;\r\n        this._letterMul = 1;\r\n    }\r\n\r\n    static fromJson(data: any): BoardTile {\r\n        const tile = new BoardTile(data._row, data._col);\r\n        tile.type = data._type;\r\n        tile.wordMultiplier = data._wordMul;\r\n        tile.letterMultiplier = data._letterMul;\r\n\r\n        if (data._tile !== null) {\r\n            tile.tile = Tile.fromJson(data._tile);\r\n        } else {\r\n            tile.tile = null;\r\n        }\r\n\r\n        return tile;\r\n    }\r\n}","import { TileTypes } from \"./BoardTile\";\r\n\r\n\r\nexport const BOARD_DIMENSIONS = 15;\r\nexport const TILES_PER_PLAYER = 7;\r\nexport const CENTER_TILE_ROW = 7;\r\nexport const CENTER_TILE_COL = 7;\r\nexport const BINGO_BONUS_POINTS = 50;\r\nexport const MAX_CONSECUTIVE_PASS = 6;\r\n\r\nexport type TileAttributes = { letter: string; count: number; points: number; }[];\r\n\r\nexport enum Languages {\r\n    English = \"English\",\r\n    Hebrew = \"Hebrew\"\r\n}\r\n\r\nexport const DefaultLanguage = Languages.Hebrew;\r\n\r\nexport const gameTiles : Record<Languages, TileAttributes> = \r\n{\r\n    [Languages.Hebrew]: [\r\n        { letter: \"א\", count: 9,  points: 1 },\r\n        { letter: \"ב\", count: 2,  points: 2 },\r\n        { letter: \"ג\", count: 3,  points: 2 },\r\n        { letter: \"ד\", count: 3,  points: 2 },\r\n        { letter: \"ה\", count: 13, points: 1 },\r\n        { letter: \"ו\", count: 4,  points: 2 },\r\n        { letter: \"ז\", count: 1,  points: 5 },\r\n        { letter: \"ח\", count: 2,  points: 3 },\r\n        { letter: \"ט\", count: 1,  points: 5 },\r\n        { letter: \"י\", count: 8,  points: 1 },\r\n        { letter: \"כ\", count: 4,  points: 2 },\r\n        { letter: \"ל\", count: 4,  points: 1 },\r\n        { letter: \"מ\", count: 4,  points: 2 },\r\n        { letter: \"נ\", count: 5,  points: 1 },\r\n        { letter: \"ס\", count: 2,  points: 2 },\r\n        { letter: \"ע\", count: 5,  points: 1 },\r\n        { letter: \"פ\", count: 4,  points: 2 },\r\n        { letter: \"צ\", count: 2,  points: 3 },\r\n        { letter: \"ק\", count: 1,  points: 4 },\r\n        { letter: \"ר\", count: 6,  points: 1 },\r\n        { letter: \"ש\", count: 7,  points: 1 },\r\n        { letter: \"ת\", count: 5,  points: 1 },\r\n        //TODO: { letter: \" \", count: 2 ,points: 0 }\r\n    ],\r\n\r\n    [Languages.English]: [\r\n        { letter: 'A', count: 9,  points: 1  },\r\n        { letter: 'B', count: 2,  points: 3  },\r\n        { letter: 'C', count: 2,  points: 3  },\r\n        { letter: 'D', count: 4,  points: 2  },\r\n        { letter: 'E', count: 12, points: 1  },\r\n        { letter: 'F', count: 2,  points: 4  },\r\n        { letter: 'G', count: 3,  points: 2  },\r\n        { letter: 'H', count: 2,  points: 4  },\r\n        { letter: 'I', count: 9,  points: 1  },\r\n        { letter: 'J', count: 1,  points: 8  },\r\n        { letter: 'K', count: 1,  points: 5  },\r\n        { letter: 'L', count: 4,  points: 1  },\r\n        { letter: 'M', count: 2,  points: 3  },\r\n        { letter: 'N', count: 6,  points: 1  },\r\n        { letter: 'O', count: 8,  points: 1  },\r\n        { letter: 'P', count: 2,  points: 3  },\r\n        { letter: 'Q', count: 1,  points: 10 },\r\n        { letter: 'R', count: 6,  points: 1  },\r\n        { letter: 'S', count: 4,  points: 1  },\r\n        { letter: 'T', count: 6,  points: 1  },\r\n        { letter: 'U', count: 4,  points: 1  },\r\n        { letter: 'V', count: 2,  points: 4  },\r\n        { letter: 'W', count: 2,  points: 4  },\r\n        { letter: 'X', count: 1,  points: 8  },\r\n        { letter: 'Y', count: 2,  points: 4  },\r\n        { letter: 'Z', count: 1,  points: 10 },\r\n        //TODO: { letter: \" \", count: 2,  points: 0 }\r\n    ]\r\n};\r\n\r\n\r\n\r\nexport type TileMultipliers = Record<TileTypes, {wordMul: number, letterMul: number, coordinates: { row: number; col: number; }[]}>;\r\n\r\nexport const tileMultipliers : TileMultipliers = {\r\n    [TileTypes.DoubleWord]: {\r\n        wordMul : 2,\r\n        letterMul: 1,\r\n        coordinates: [\r\n            { row: 1,  col: 1  },\r\n            { row: 2,  col: 2  },\r\n            { row: 3,  col: 3  },\r\n            { row: 4,  col: 4  },\r\n            { row: 10, col: 10 },\r\n            { row: 11, col: 11 },\r\n            { row: 12, col: 12 },\r\n            { row: 13, col: 13 },\r\n            { row: 1,  col: 13 },\r\n            { row: 2,  col: 12 },\r\n            { row: 3,  col: 11 },\r\n            { row: 4,  col: 10 },\r\n            { row: 10, col: 4  },\r\n            { row: 11, col: 3  },\r\n            { row: 12, col: 2  },\r\n            { row: 13, col: 1  }\r\n        ]\r\n    },\r\n\r\n    [TileTypes.DoubleLetter]: {\r\n        wordMul : 1,\r\n        letterMul: 2,\r\n        coordinates: [\r\n            { row: 0,  col: 3  },\r\n            { row: 0,  col: 11 },\r\n            { row: 2,  col: 6  },\r\n            { row: 2,  col: 8  },\r\n            { row: 3,  col: 0  },\r\n            { row: 3,  col: 7  },\r\n            { row: 3,  col: 14 },\r\n            { row: 6,  col: 2  },\r\n            { row: 6,  col: 6  },\r\n            { row: 6,  col: 8  },\r\n            { row: 6,  col: 12 },\r\n            { row: 7,  col: 3  },\r\n            { row: 7,  col: 11 },\r\n            { row: 8,  col: 2  },\r\n            { row: 8,  col: 6  },\r\n            { row: 8,  col: 8  },\r\n            { row: 8,  col: 12 },\r\n            { row: 11, col: 0  },\r\n            { row: 11, col: 7  },\r\n            { row: 11, col: 14 },\r\n            { row: 12, col: 6  },\r\n            { row: 12, col: 8  },\r\n            { row: 14, col: 3  },\r\n            { row: 14, col: 11 }\r\n        ]\r\n    },\r\n    [TileTypes.TripleWord]: {\r\n        wordMul : 3,\r\n        letterMul: 1,\r\n        coordinates: [\r\n            { row: 0,  col: 0  },\r\n            { row: 0,  col: 7  },\r\n            { row: 0,  col: 14 },\r\n            { row: 7,  col: 0  },\r\n            { row: 7,  col: 14 },\r\n            { row: 14, col: 0  },\r\n            { row: 14, col: 7  },\r\n            { row: 14, col: 14 }\r\n        ]\r\n    },\r\n\r\n    [TileTypes.TripleLetter]: {\r\n        wordMul : 1,\r\n        letterMul: 3,\r\n        coordinates: [\r\n            { row: 1,  col: 5  },\r\n            { row: 1,  col: 9  },\r\n            { row: 5,  col: 1  },\r\n            { row: 5,  col: 5  },\r\n            { row: 5,  col: 9  },\r\n            { row: 5,  col: 13 },\r\n            { row: 9,  col: 1  },\r\n            { row: 9,  col: 5  },\r\n            { row: 9,  col: 9  },\r\n            { row: 9,  col: 13 },\r\n            { row: 13, col :5  },\r\n            { row: 13, col :9  }\r\n        ]\r\n    },\r\n\r\n    [TileTypes.Regular]: {\r\n        wordMul : 1,\r\n        letterMul: 1,\r\n        coordinates: [\r\n\r\n        ]\r\n    },\r\n\r\n    [TileTypes.CenterTile]: {\r\n        wordMul : 2,\r\n        letterMul: 1,\r\n        coordinates: [\r\n            { row: CENTER_TILE_ROW, col: CENTER_TILE_COL }\r\n        ]\r\n    },\r\n\r\n}\r\n","import BoardTile, {TileTypes} from './BoardTile'\r\nimport {Tile} from './Tile';\r\nimport * as Constants from \"./Constants\";\r\n\r\n/**\r\n * Board class represents the game board.\r\n * This class allows viewing the tiles on the board but not modifying them.\r\n * @class\r\n */\r\nexport class Board \r\n{\r\n    private   _size: number;\r\n    protected tiles: BoardTile[][];\r\n  \r\n    /**\r\n     * Constructs a new Board object with the specified size, and initializes the special tiles on the board.\r\n     * @param size - The size of the board.\r\n     */\r\n    constructor(size: number, multipliers: Constants.TileMultipliers) \r\n    {\r\n        this._size = size;\r\n        this.tiles = new Array(size).fill(null).map(() => new Array(size).fill(null));\r\n        for (let row = 0; row < size; row++) \r\n        {\r\n            for (let col = 0; col < size; col++) \r\n            {\r\n                this.tiles[row][col] = new BoardTile(row, col);\r\n            }\r\n        }\r\n\r\n        Object.keys(multipliers).forEach((key, index) => {\r\n            let type = key as keyof typeof multipliers;\r\n            let wordMul = multipliers[type].wordMul;\r\n            let letterMul = multipliers[type].letterMul;\r\n            multipliers[type].coordinates.forEach((coordinates) => {\r\n                this.tiles[coordinates.row][coordinates.col].type = type;\r\n                this.tiles[coordinates.row][coordinates.col].wordMultiplier = wordMul;\r\n                this.tiles[coordinates.row][coordinates.col].letterMultiplier = letterMul;\r\n            })\r\n        });\r\n        \r\n    }\r\n\r\n    /**\r\n     * Returns a BoardTile object at the specified row and column of the board.\r\n     * @param row - The row of the board.\r\n     * @param col - The column of the board.\r\n     * @returns The BoardTile object at the specified row and column of the board.\r\n     */\r\n    getBoardTileType(row: number, col: number): TileTypes\r\n    {\r\n        return this.tiles[row][col].type;\r\n    }\r\n\r\n    /**\r\n     * Returns a Tile object (or null if it's empty) at the specified row and column of the board.\r\n     * @param row - The row of the board.\r\n     * @param col - The column of the board.\r\n     * @returns The Tile object or null at the specified row and column of the board.\r\n     */\r\n    getTile(row: number, col: number): Tile | null\r\n    {\r\n        return this.tiles[row][col].tile;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the tile at the specified row and column of the board is empty.\r\n     * @param row - The row of the board.\r\n     * @param col - The column of the board.\r\n     * @returns True if the tile at the specified row and column of the board is empty.\r\n     */\r\n    isTileEmpty(row: number, col: number) : boolean\r\n    {\r\n        return (this.getTile(row, col) == null);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the location at the specified row and column of the board is within bounds of the board.\r\n     * @param row - The row of the board.\r\n     * @param col - The column of the board.\r\n     * @returns True if the location at the specified row and column of the board is within bounds of the board.\r\n     */\r\n    isTileInBoard(row: number, col: number) : boolean\r\n    {\r\n        return (row >= 0 && col >= 0 && row < this.height && col < this.width);\r\n    }\r\n\r\n    /**\r\n     * Returns the width of the board.\r\n     * @returns The width of the board.\r\n     */\r\n    get width(): number\r\n    {\r\n        return this._size;\r\n    }\r\n\r\n    /**\r\n     * Returns the height of the board.\r\n     * @returns The height of the board.\r\n     */\r\n    get height(): number\r\n    {\r\n        return this._size;\r\n    }\r\n\r\n    static fromJson(data: any): Board {\r\n        const board = new Board(data._size, {} as Constants.TileMultipliers);\r\n        for (let row = 0; row < data.tiles.length; row++) {\r\n            for (let col = 0; col < data.tiles[row].length; col++) {\r\n                board.tiles[row][col] = BoardTile.fromJson(data.tiles[row][col]);\r\n            }\r\n        }\r\n        return board;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * ModifiableBoard class extends Board, allowing to modify tiles on the board.\r\n * @class\r\n */\r\nexport class ModifiableBoard extends Board\r\n{\r\n    constructor(size: number, multipliers: Constants.TileMultipliers) \r\n    {\r\n        super(size, multipliers);\r\n    }\r\n\r\n    /**\r\n     * Sets a tile at the specified row and column of the board.\r\n     * @param row - The row of the board.\r\n     * @param col - The column of the board.\r\n     * @param tile - The tile to set at the specified row and column of the board, or null (to remove a tile).\r\n     */\r\n    setTile(row: number, col: number, tile: Tile | null): void \r\n    {\r\n        this.tiles[row][col].tile = tile;\r\n    }\r\n\r\n    /**\r\n     * Returns a BoardTile object at the specified row and column of the board.\r\n     * @param row - The row of the board.\r\n     * @param col - The column of the board.\r\n     * @returns The BoardTile object at the specified row and column of the board.\r\n     */\r\n    getBoardTile(row: number, col: number): BoardTile\r\n    {\r\n        return this.tiles[row][col];\r\n    }\r\n}","import {Bag} from \"./Bag\";\r\nimport {TilePlacement, Tile} from \"./Tile\";\r\nimport {Board} from \"./Board\";\r\n\r\nexport enum PlayerType {\r\n    Human           = \"Human\",\r\n}\r\n\r\n/**\r\n * Represents a Player\r\n */\r\nexport abstract class Player\r\n{\r\n    private     _name        :   string;\r\n    private     _id          :   string;\r\n    private     _index       :   number;\r\n    private     maxTileNum   :   number;\r\n    private     _rack        :   Set<Tile>;\r\n    private     _points      :   number;\r\n    private     _playerType  :   PlayerType;\r\n\r\n    protected constructor(name: string, id: string, index: number, maxTileNum: number, playerType: PlayerType)\r\n    {\r\n        this._name = name;\r\n        this._id = id;\r\n        this._index = index;\r\n        this.maxTileNum = maxTileNum;\r\n        this._points = 0;\r\n        this._rack = new Set<Tile>();\r\n        this._playerType = playerType;\r\n    }\r\n\r\n    /**\r\n     * Fill the rack with up to maxTileNum from the Bag\r\n     * @param bag The bag to fill the rack from\r\n     */\r\n    public fillRack(bag: Bag) : void\r\n    {\r\n        while ( (this._rack.size < this.maxTileNum) && (bag.length > 0) )\r\n        {\r\n            this._rack.add(bag.draw()!);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Replace the current rack with the provided one\r\n     * @param tiles The tiles to add to the rack\r\n     */\r\n    public setRack(tiles: Tile[]) : void\r\n    {\r\n        this._rack = new Set<Tile>();\r\n        tiles.forEach((tile) => {\r\n            this._rack.add(tile);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Remove the given tile from the rack\r\n     * @param tile The tile to remove from the rack\r\n     */\r\n    public removeTile(tile: Tile) : void\r\n    {\r\n        for (const elem of this._rack) \r\n        {\r\n            if (tile.equals(elem)) \r\n            {\r\n                this._rack.delete(elem);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if the player's rack contains the given tile\r\n     * @param tile The tile to check \r\n     * @returns True if the player's rack contains the given tile\r\n     */\r\n    public hasTile(tile: Tile) : boolean\r\n    {\r\n        //return this._rack.has(tile);\r\n        for (const elem of this._rack) \r\n        {\r\n            if (tile.equals(elem)) \r\n            {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Return a copy of the rack\r\n     */\r\n    get rack() : Tile[]\r\n    {\r\n        return [...this._rack];\r\n    }\r\n\r\n    /**\r\n     * Return the player id\r\n     */\r\n    get id() : string\r\n    {\r\n        return this._id;\r\n    }\r\n\r\n    /**\r\n     * Return the player index\r\n     */\r\n    get index() : number\r\n    {\r\n        return this._index;\r\n    }\r\n\r\n    /**\r\n     * Return the player name\r\n     */\r\n    get name() : string\r\n    {\r\n        return this._name;\r\n    }\r\n\r\n    /**\r\n     * Set the player name\r\n     */\r\n    set name(value: string)\r\n    {\r\n        this._name = value;\r\n    }\r\n\r\n    /**\r\n     * Return the player points\r\n     */\r\n    get points() : number\r\n    {\r\n        return this._points;\r\n    }\r\n\r\n    /**\r\n     * Set the player points\r\n     */\r\n    set points(value: number)\r\n    {\r\n        if (value < 0)\r\n        {\r\n            throw \"Points must be non-negative\";\r\n        }\r\n\r\n        this._points = value;\r\n    }\r\n\r\n    /**\r\n     * Return the player type\r\n     */\r\n    get playerType() : PlayerType\r\n    {\r\n        return this._playerType;\r\n    }\r\n\r\n    /**\r\n     * Get the player's move. Relevant only if automaticMode() == True, i.e. if it's not a human player\r\n     * @param calculatePoints \r\n     */\r\n    public abstract getMove(calculatePoints: (tilePlacements: TilePlacement[]) => number) : TilePlacement[];\r\n\r\n    /**\r\n     * Returns true if and only if this player performs moves automatically, i.e. it's not a human player\r\n     */\r\n    public abstract automaticMode() : boolean;\r\n\r\n    /**\r\n     * Factory method to create players.\r\n     * @param name The player name\r\n     * @param id The player number\r\n     * @param maxTileNum The maximum number of tiles for the player rack\r\n     * @param playerType The player type\r\n     * @returns A new player\r\n     */\r\n    public static createPlayer(name: string, id: string, index: number, maxTileNum: number, playerType: PlayerType) : Player\r\n    {\r\n        switch(playerType)\r\n        {\r\n            case (PlayerType.Human):\r\n                return new HumanPlayer(name, id, index, maxTileNum);\r\n            default:\r\n                throw new Error(`Unknown player type '${playerType}!`);\r\n        }\r\n    }\r\n\r\n    public static fromJson(data: any): Player {\r\n        switch (data._playerType) {\r\n            case PlayerType.Human:\r\n                return HumanPlayer.fromJson(data);\r\n            default:\r\n                throw new Error(`Unknown player type '${data._playerType}' in fromJson`);\r\n        }\r\n    }\r\n\r\n    public static toJson(player: Player): any {\r\n        return {\r\n            _name: player.name,\r\n            _id: player.id,\r\n            _index : player.index,\r\n            _points: player.points,\r\n            maxTileNum: player['maxTileNum'],\r\n            _playerType: player.playerType,\r\n            _rack: Array.from(player._rack.values()).map(tile => ({\r\n                _letter: tile.letter,\r\n                _points: tile.points,\r\n                _id: tile.id\r\n            }))\r\n        };\r\n    }\r\n}\r\n\r\nexport class HumanPlayer extends Player\r\n{\r\n    constructor(name: string, id: string, index: number, maxTileNum: number)\r\n    {\r\n        super(name, id, index, maxTileNum, PlayerType.Human);\r\n    }\r\n\r\n    public getMove(calculatePoints: (tilePlacements: TilePlacement[]) => number) : TilePlacement[]\r\n    {\r\n        throw new Error(\"Not implemented!\");\r\n    }\r\n\r\n    public automaticMode() : boolean\r\n    {\r\n        return false;\r\n    }\r\n\r\n    static fromJson(data: any): HumanPlayer {\r\n        const player = new HumanPlayer(data._name, data._id, data._index, data.maxTileNum);\r\n        player.points = data._points;\r\n        console.log(data._rack)\r\n        const tiles = data._rack.map((tileJson: any) => Tile.fromJson(tileJson));\r\n        player.setRack(tiles);\r\n        return player;\r\n    }\r\n}\r\n\r\nconst enum Direction \r\n{\r\n    ACROSS,\r\n    DOWN\r\n}\r\n","import * as Constants from \"./Constants\"\r\n\r\n/**\r\n * Shuffle an array\r\n * https://stackoverflow.com/questions/48083353/\r\n */\r\nexport function shuffle<T>(array: T[]): T[] {\r\n    let currentIndex = array.length,  randomIndex;\r\n    \r\n    // While there remain elements to shuffle.\r\n    while (currentIndex != 0) {\r\n        \r\n    // Pick a remaining element.\r\n    randomIndex = Math.floor(Math.random() * currentIndex);\r\n    currentIndex--;\r\n    \r\n    // And swap it with the current element.\r\n    [array[currentIndex], array[randomIndex]] = [\r\n        array[randomIndex], array[currentIndex]];\r\n    }\r\n    \r\n    return array;\r\n};\r\n    \r\n/**\r\n * Returns True of the given key is a key of the given object\r\n * @param key The key\r\n * @param obj The object\r\n * @returns True if the given key is a key of the given object\r\n */\r\nexport function isKeyOfObject<T extends object>(\r\n    key: string | number | symbol,\r\n    obj: T,\r\n): key is keyof T {\r\n    return key in obj;\r\n}\r\n","import {Tile} from \"./Tile\";\r\nimport { shuffle } from \"./Utils\";\r\nimport {TileAttributes} from \"./Constants\"\r\n\r\n/**\r\n * Bag class represents a bag of tiles.\r\n * @class\r\n */\r\nexport class Bag \r\n{\r\n    private tiles: Tile[] = [];\r\n    private tilesById: Map<number, Tile> = new Map<number, Tile>();\r\n  \r\n    /**\r\n     * Creates an instance of Bag and shuffles it\r\n     * @param tileCounts - An array describing the different tiles, their count and points\r\n     */\r\n    constructor(tileCounts: TileAttributes) \r\n    {  \r\n        for (const tileCount of tileCounts) \r\n        {\r\n            for (let i = tileCount.count; i > 0; i--) \r\n            {\r\n                const tile = new Tile(tileCount.letter, tileCount.points);\r\n                this.tiles.push(tile);\r\n                this.tilesById.set(tile.id, tile);\r\n            }\r\n        }\r\n\r\n        this.shuffle();\r\n    }\r\n\r\n    /**\r\n     * Draws a tile from the bag.\r\n     * @returns The drawn tile or null if the bag is empty.\r\n     */\r\n    public draw() : Tile | null\r\n    {\r\n        if (this.tiles.length > 0)\r\n        {\r\n            return this.tiles.pop()!;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Adds a tile to the bag.\r\n     * @param tile - The tile to add.\r\n     */\r\n    public add(tile: Tile) : void\r\n    {\r\n        this.tiles.push(tile);\r\n    }\r\n\r\n    /**\r\n     * Shuffles the tiles in the bag.\r\n     */\r\n    public shuffle() : void \r\n    {\r\n        this.tiles = shuffle(this.tiles);\r\n    }\r\n\r\n    /**\r\n     * Gets the number of tiles in the bag.\r\n     * @returns The number of tiles in the bag.\r\n     */\r\n    get length() : number\r\n    {\r\n        return this.tiles.length;\r\n    }\r\n\r\n    public getTileById(id: number) : Tile | null\r\n    {\r\n        const tile = this.tilesById.get(id);\r\n        return tile !== undefined ? tile : null;\r\n    }\r\n}","import { PlayerType } from \"./Player\";\nimport { Tile } from \"./Tile\";\n\nexport type PlayerDetails = \n{\n    id          : string,\n    name        : string,\n    playerType  : PlayerType\n}\n\nexport type GameConfiguration = \n{\n    playerDetails: PlayerDetails[];\n    checkDict: boolean;\n}\n\nexport enum GameErrorTypes {\n    PlacementConsecutive,\n    PlacementConnected,\n    PlacementExisting,\n    PlacementIllegalWord,\n    PlacementFirstWordMin,\n    PlacementFirstWordLocation,\n    UserDoesntHaveTile\n}\n\nexport class UserError extends Error {\n    public extraData : any;\n    public type : GameErrorTypes;\n    constructor(type: GameErrorTypes, extraData: any = null) \n    {\n        super(`The following error occurred: ${type.toString()}`);\n        this.extraData = extraData;\n        this.type = type;\n    }\n}\n\nexport type WordInfo = {\n    word: string;\n    startIndex: { x: number, y: number };\n    points: number;\n}\n\nexport type MoveDetails = {\n    playerIndex: number;\n    points: number, \n    placedWords: WordInfo[], \n    bonusPoints: number\n}\n\nexport type SwapDetails = {\n    playerIndex: number;\n    oldTiles: Tile[]\n}","import * as Constants from '@shared/Constants.js';\nimport {ModifiableBoard, Board} from '@shared/Board.js'\nimport {Player, PlayerType} from '@shared/Player.js';\nimport {Bag} from '@shared/Bag.js';\nimport {TilePlacement, Tile} from '@shared/Tile.js';\nimport Dictionary from './Dictionary.js';\nimport {GameConfiguration, PlayerDetails, UserError, GameErrorTypes, WordInfo, MoveDetails, SwapDetails} from '@shared/SharedGame.js'\n\nexport default class ServerGame \n{\n    public board!               : ModifiableBoard;\n    public bag!                 : Bag;\n    private players!            : Player[];\n    private currentPlayerIndex! : number;\n    private firstTurnPlayed!    : boolean;\n    private dictionary!         : Dictionary;\n    private checkDict!          : boolean;\n    private consecutivePasses!  : number;\n    private _isGameOver!        : boolean;\n    private numPlayers          : number;\n  \n    constructor(dictionary: Dictionary, numPlayers: number) \n    {\n        const that = this;\n\n        this.dictionary = dictionary;\n        this.numPlayers = numPlayers;\n        this.players = [];\n\n        this.newGame();\n    }\n\n    /**\n     * Starts a new game based on the given configuration\n     */\n    public newGame() : void\n    {\n        this.board = new ModifiableBoard(Constants.BOARD_DIMENSIONS, Constants.tileMultipliers);\n        this.currentPlayerIndex = 0;\n        this.bag = new Bag(Constants.gameTiles[Constants.DefaultLanguage]);\n        this.firstTurnPlayed = false;\n        this.checkDict = true;\n        this.consecutivePasses = 0;\n        this._isGameOver = false;\n    }\n\n    /**\n     * Create the players for the game\n     * @param players The player details to use for creating the players\n     * @param basedOnCurrent True if the new players should inherit the rack and points from the current players, False otherwise\n     * @returns The new players created\n     */\n    public addPlayer(player: PlayerDetails) : Player\n    {\n        let newPlayer: Player | null = null;\n        this.players.forEach((existingPlayer) => {\n            if (player.id == existingPlayer.id) {\n                newPlayer = existingPlayer;\n            }\n        });\n        \n        if (newPlayer != null)\n        {\n            console.log(`Found player ${player.id}`, newPlayer);\n            return newPlayer;\n        }\n\n        if (this.allPlayersJoined())\n        {\n            throw new Error(`Can't add more than ${this.numPlayers} players`);\n        }\n\n        newPlayer = Player.createPlayer(player.name, player.id, this.players.length,\n                                        Constants.TILES_PER_PLAYER, player.playerType);\n                                              \n        newPlayer.fillRack(this.bag);\n        this.players.push(newPlayer);\n\n        if (this.allPlayersJoined())\n        {\n            this.currentPlayerIndex = this.players.length - 1;\n            this.moveToNextPlayer();\n        }\n\n        return newPlayer;\n    }\n\n    public allPlayersJoined() : boolean \n    {\n        return (this.players.length == this.numPlayers);\n    }\n\n    public checkWord(word: string)\n    {\n        return this.dictionary.contains(word);\n    }\n\n    /**\n     * Return the current game configuration\n     * @returns The current game configuration\n     */\n    /*\n    public getConfiguration() : GameConfiguration\n    {\n        return {\n            playerDetails: this.players.map(player => {\n                return {name: player.name, playerType: player.playerType}\n            }),\n            checkDict: this.checkDict\n        }\n    }\n    */\n\n    /**\n     * Set the current game configuration\n     * @param config The configuration to be used\n     * @returns True if the configuration was legal, False otherwise\n     */\n    /*\n    private setConfigurationCallback(config: GameConfiguration) : boolean\n    {\n        try\n        {\n\n            if (config.playerDetails.length != this.players.length)\n            {\n                throw Error(\"Number of player names should match number of players\");\n            }\n    \n            config.playerDetails.forEach((details) => {\n                details.name = details.name.trim();\n                if (details.name == \"\")\n                {\n                    throw Error(\"Player name can't be empty or only spaces\");\n                }\n            });\n    \n            this.checkDict = config.checkDict;\n            this.players = this.createPlayers(config.playerDetails, true);\n        \n            //this.display.setPlayerNames(this.players);\n\n            this.playAutoTurnIfNeeded();\n    \n            return true;\n        }\n        catch (err)\n        {\n            return false;\n        }\n    }\n    */\n\n    /**\n     * Callback for the Display to check if a given word exists in the dictionary\n     * @param word The word to check\n     * @returns True if the word exists in the dictionary, False otherwise\n     */\n    private checkWordCallback(word: string) : boolean\n    {\n        return this.dictionary.contains(word);\n    }\n\n    /**\n     * Callback for the Display to swap tiles for the current player\n     * @param tiles The tiles to swap\n     */\n    public swapTiles(tiles: Tile[]) : SwapDetails | null\n    {\n        if (tiles.length > this.currentPlayer.rack.length)\n        {\n            return null;\n        }\n\n        const numTiles = Math.min(tiles.length, this.bag.length);\n\n        for (let i = 0; i < numTiles; i++)\n        {\n            if (!this.currentPlayer.hasTile(tiles[i]))\n            {\n                return null;\n            }\n        }\n        \n        const oldTiles : Tile[] = [];\n        for (let i = 0; i < numTiles; i++)\n        {\n            this.currentPlayer.removeTile(tiles[i]);\n            oldTiles.push(tiles[i]);\n        }\n        this.currentPlayer.fillRack(this.bag);\n\n        oldTiles.forEach((tile) => {\n            this.bag.add(tile);\n        })\n\n        this.bag.shuffle();\n\n        this.consecutivePasses += 1;\n\n        const swapDetails = {\n            playerIndex: this.currentPlayer.index,\n            oldTiles: oldTiles\n        }\n\n        this.moveToNextPlayer();\n\n        return swapDetails;\n    }\n\n    /**\n     * Given a tile placement, return all the word (and points) for the words created as part of this placement\n     * @param tilePlacements An array representing the tiles placed on the board\n     * @returns The different words (and their matching points) created as part of this placement\n     */\n    private getCreatedWords(tilePlacements: TilePlacement[]): WordInfo[] \n    {\n        const words = new Set<string>();\n        const axes = [\"r\", \"c\"];\n\n        for (const placement of tilePlacements) {\n            for (let axis of axes)\n            {\n                let word = \"\";\n                let points = 0;\n                let start_index = { r: -1, c: -1 };\n                \n                // Scan vertically up\n                let current = {r: placement.r, c: placement.c};\n                while (this.board.isTileInBoard(current[\"r\"], current[\"c\"]) && !this.board.isTileEmpty(current[\"r\"], current[\"c\"])) \n                {\n                    start_index = { r: current[\"r\"], c: current[\"c\"] };\n                    current[axis as keyof typeof current]--;\n                }\n                \n                // Reset to starting tile\n                current[\"r\"] = start_index.r;\n                current[\"c\"] = start_index.c;\n                \n                // Scan vertically down\n                let wordMultiplier = 1;\n\n                while (this.board.isTileInBoard(current[\"r\"], current[\"c\"]) && !this.board.isTileEmpty(current[\"r\"], current[\"c\"])) \n                {\n                    let tile = this.board.getTile(current[\"r\"], current[\"c\"])!;\n                    let boardTile = this.board.getBoardTile(current[\"r\"], current[\"c\"])!;\n                    \n                    word += tile.letter;\n                    points += (tile.points * boardTile.letterMultiplier);\n                    current[axis as keyof typeof current]++;\n                    wordMultiplier *= boardTile.wordMultiplier;\n                }\n\n                points *= wordMultiplier;\n                \n                if (word.length > 1) \n                {\n                    // Use JSON.stringify to maintain the set property\n                    words.add(JSON.stringify({ word, start_index: start_index, points: points }));\n                }\n            }\n        }\n        \n        return Array.from(words, (JSONEntry) => JSON.parse(JSONEntry));\n    }\n\n    /**\n     * Calculate the amount of points the player is entitled to as part of the given placement\n     * @param tilePlacements An array representing the tiles placed on the board \n     * @param placedWords An array representing the words created as part of this placement\n     * @returns A tuple with the amount of points for the word placement and the amount of bonus points for this placement\n     */\n    private calculatePoints(tilePlacements: TilePlacement[], placedWords: WordInfo[]) : [number, number]\n    {\n        let newPoints = 0;\n        let bonusPoints = 0;\n\n        for (const placedWord of placedWords) \n        {\n            newPoints += placedWord.points;\n        }\n        if (tilePlacements.length == Constants.TILES_PER_PLAYER)\n        {\n            bonusPoints = Constants.BINGO_BONUS_POINTS;\n        }\n\n        return [newPoints, bonusPoints];\n    }\n\n    /**\n     * Verify that the given tiles were placed in a consecutive manner\n     * @param tilePlacements An array representing the tiles placed on the board \n     * @returns True if the tiles were placed consecutively on the board\n     */\n    private verifyPlacementConsecutive(tilePlacements: TilePlacement[]) : boolean\n    {\n        if (tilePlacements.length > 0)\n        {\n            const rValues = tilePlacements.map((tilePlacement) => tilePlacement.r);\n            const cValues = tilePlacements.map((tilePlacement) => tilePlacement.c);\n            \n            const rSet = new Set(rValues);\n            const cSet = new Set(cValues);\n            \n            let axis: keyof TilePlacement;\n            if (rSet.size === 1)\n            {\n                // All the tiles are placed in the same row\n                axis = \"c\" as keyof TilePlacement;\n            }\n            else if (cSet.size === 1)\n            {\n                // All the tiles are placed in the same column\n                axis = \"r\" as keyof TilePlacement;\n            }\n            else\n            {\n                return false;\n            }\n\n            // Search for the minimum and maximum value for the non-constant axis\n            const minMax = tilePlacements.reduce((acc, curr) => {\n                let n : number = curr[axis] as number;\n                return [\n                    Math.min(acc[0], n),\n                    Math.max(acc[1], n)\n                ];\n            }, [Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n\n            // Check that the tiles are consecutive\n            if (rSet.size === 1)\n            {\n                for (let c = minMax[0]; c <= minMax[1]; c++)\n                {\n                    if (this.board.isTileEmpty(rValues[0], c) && !cSet.has(c))\n                    {\n                        return false;\n                    }\n                }\n            }\n            else if (cSet.size === 1)\n            {\n                for (let r = minMax[0]; r <= minMax[1]; r++)\n                {\n                    if (this.board.isTileEmpty(r, cValues[0]) && !rSet.has(r))\n                    {\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Verify that all the tiles placed during this turn are connected legally\n     * @param tilePlacements An array representing the tiles placed on the board \n     * @returns True if all the tiles are connected legally\n     */\n    private verifyPlacementConnected(tilePlacements: TilePlacement[]) : boolean\n    {\n        if (this.firstTurnPlayed && tilePlacements.length > 0)\n        {\n            let connected = false;\n            for (const tilePlacement of tilePlacements) \n            {\n                for (const [dr, dc] of [[1, 0], [-1, 0], [0, 1], [0, -1]])\n                {\n                    let new_r = tilePlacement.r + dr;\n                    let new_c = tilePlacement.c + dc;\n                    if (this.board.isTileInBoard(new_r, new_c) && !this.board.isTileEmpty(new_r, new_c))\n                    {\n                        connected = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!connected) \n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Move to the next player after the current player ended their turn\n     */\n    private moveToNextPlayer() : void\n    {\n        this.currentPlayerIndex = (this.currentPlayerIndex + 1) % this.players.length;\n    }\n\n    /**\n     * Callback for the Display to handle the end of a turn\n     * @param tilePlacements An array representing the tiles placed on the board \n     * @param forceObjection True if the user requests to override the dictionary check\n     */\n    public endTurnCallback(tilePlacements: TilePlacement[], forceObjection: boolean) : MoveDetails | null\n    {\n        const actualTilePlacements : TilePlacement[] = [];\n\n        try\n        {\n            if (!this.verifyPlacementConsecutive(tilePlacements))\n            {\n                throw new UserError(GameErrorTypes.PlacementConsecutive);\n            }\n\n            if (!this.verifyPlacementConnected(tilePlacements))\n            {\n                throw new UserError(GameErrorTypes.PlacementConnected);\n            }\n\n            for (const tilePlacement of tilePlacements) \n            {\n                if (!this.board.isTileEmpty(tilePlacement.r, tilePlacement.c)) \n                {\n                    throw new UserError(GameErrorTypes.PlacementExisting);\n                }\n\n                console.log(tilePlacement.tile)\n                if (!this.currentPlayer.hasTile(tilePlacement.tile)) \n                {\n                    throw new UserError(GameErrorTypes.UserDoesntHaveTile);\n                }\n\n                // Mark the placed tile as placed\n                this.board.setTile(tilePlacement.r, tilePlacement.c, tilePlacement.tile);\n                actualTilePlacements.push(tilePlacement);\n            }\n\n            const placedWords: WordInfo[] = this.getCreatedWords(tilePlacements);\n\n            // Check if all placedWords are valid words\n            const illegalWords : string[] = [];\n            if (this.checkDict && !forceObjection)\n            {\n                for (const placedWord of placedWords) \n                {\n                    if (!this.dictionary.contains(placedWord.word))\n                    {\n                        illegalWords.push(placedWord.word);\n                    }\n                }\n            }\n            if (illegalWords.length > 0)\n            {\n                throw new UserError(GameErrorTypes.PlacementIllegalWord, illegalWords);\n            }\n\n            if (!this.firstTurnPlayed)\n            {\n                if (tilePlacements.length == 1)\n                {\n                    throw new UserError(GameErrorTypes.PlacementFirstWordMin);\n                }\n                else if (tilePlacements.length > 0)\n                {\n                    let centerTileUsed = false;\n\n                    tilePlacements.forEach((tilePlacement) => {\n                        if ( (tilePlacement.r == Constants.CENTER_TILE_ROW) && (tilePlacement.c == Constants.CENTER_TILE_COL) ) \n                        {\n                            centerTileUsed = true;\n                        }\n                    });\n\n                    if (!centerTileUsed)\n                    {\n                        throw new UserError(GameErrorTypes.PlacementFirstWordLocation);\n                    }\n\n                    this.firstTurnPlayed = true;\n                }\n            }\n            \n            // All checks passed, move is good\n\n            let [newPoints, bonusPoints] = this.calculatePoints(tilePlacements, placedWords);\n            this.currentPlayer.points += newPoints + bonusPoints;\n            \n            tilePlacements.forEach((tilePlacement) => {\n                this.currentPlayer.removeTile(tilePlacement.tile);\n                this.board.getBoardTile(tilePlacement.r, tilePlacement.c).disableMultiplier();\n            });\n\n            this.currentPlayer.fillRack(this.bag);\n            \n            if (tilePlacements.length == 0)\n            {\n                this.consecutivePasses += 1;\n            }\n            else\n            {\n                this.consecutivePasses = 0;\n            }\n\n            const MoveDetails = {\n                playerIndex: this.currentPlayer.index,\n                points: newPoints,\n                placedWords: placedWords,\n                bonusPoints: bonusPoints\n            }\n\n            if ( (this.currentPlayer.rack.length == 0) || (this.consecutivePasses == Constants.MAX_CONSECUTIVE_PASS) )\n            {\n                //this.display.gameOver(this.getLeadingPlayer());\n                this._isGameOver = true;\n            }\n            else\n            {\n                this.moveToNextPlayer();\n            }\n\n            return MoveDetails;\n        }\n        catch(err) \n        {\n            actualTilePlacements.forEach((tilePlacement) => {\n                this.board.setTile(tilePlacement.r, tilePlacement.c, null);\n            });\n            if (err instanceof UserError) \n            {\n                throw err;\n            }\n            else if (err instanceof Error)\n            {\n                console.log(err.message);\n            }\n            else\n            {\n                console.log(err);\n            }\n\n            return null;\n        }\n    }\n\n    /**\n     * Returns the leading player at this time, according to the amount of points (or null if there's a tie)\n     * @returns The leading player at this time\n     */\n    public getLeadingPlayer() : Player | null\n    {\n        let res: Player | null = null;\n        let tie = true;\n        this.players.forEach((player) => {\n            if (res == null)\n            {\n                res = player;\n            }\n            else\n            {\n                if (player.points > res.points)\n                {\n                    res = player;\n                    tie = false;\n                }\n                else if (player.points < res.points)\n                {\n                    tie = false;\n                }\n            }\n        });\n\n        if (tie)\n        {\n            return null;\n        }\n        return res;\n    }\n    \n    /**\n     * Returns the current player\n     */\n    public get currentPlayer(): Player \n    {\n        return this.players[this.currentPlayerIndex];\n    }\n\n    public isGameOver() : boolean\n    {\n        return this._isGameOver;\n    }\n\n    /**\n     * Get a map of the points for each player (player index -> player points)\n     * @returns A map of the points for each player\n     */\n    public getPoints() : Map<number, number>\n    {\n        const points = new Map<number, number>();\n        this.players.forEach((player) => {\n            points.set(player.index, player.points);\n        });\n        return points;\n    }\n}\n\n","import { Server, Socket } from 'socket.io';\nimport ServerGame from './gameLogic.js';\nimport Dictionary from './Dictionary.js';\nimport {Player, PlayerType} from '@shared/Player.js';\nimport { validate as uuidValidate, version as uuidVersion } from 'uuid';\nimport { UserError } from \"@shared/SharedGame.js\";\nimport {TilePlacement, Tile} from \"@shared/Tile.js\";\n\nconst CLEANUP_DELAY = 5 * 60 * 1000; // 5 minutes in milliseconds\nconst CLEANUP_INTERVAL = 30 * 60 * 1000; // Check for inactivity every x minutes\nconst INACTIVITY_THRESHOLD = 60 * 60 * 1000; // Remove games inactive for x minutes\n\ntype GameData = {\n    serverGame        : ServerGame\n    isMarkedForDelete : boolean\n    lastActivity      : number\n}\n\nconst games: { [key: string]: GameData } = {};\n\ninterface GameSocket extends Socket {\n    gameId?: string\n    player?: Player\n}\n\nfunction isValidGameID(gameId: string) {\n    return /^[A-Za-z0-9_-]{1,32}$/.test(gameId);\n}\n\nfunction cleanupInactiveGames() {\n    const now = Date.now();\n    for (const gameId in games) {\n        const game = games[gameId];\n        if (now - game.lastActivity > INACTIVITY_THRESHOLD) {\n            console.log(`Removing inactive game ${gameId}`);\n            delete games[gameId];\n        }\n    }\n}\n\nfunction generateGameId(): string {\n    return Math.random().toString(36).substring(2, 8);\n}\n\nexport function createNewGame(dictionary: Dictionary, gameId: string | null) : string {\n    if (Object.keys(games).length > 100)\n    {\n        throw new Error(`Max number of supported games reached!`);\n    }\n\n    if (gameId == null)\n    {\n        gameId = generateGameId();\n    }\n\n    const game = {\n        serverGame : new ServerGame(dictionary, 2),\n        isMarkedForDelete : false,\n        lastActivity      : Date.now()\n    }\n    game.serverGame.newGame();\n    games[gameId] = game;\n\n    console.log(`New game created: ${gameId}`);\n\n    return gameId;\n}\n\nexport function checkGameId(gameId: string) : boolean {\n    return gameId in games;\n}\n\n\nexport function onlineGameManager(io: Server, dictionary: Dictionary) {\n    console.log('onlineGameManager initialized');\n\n    setInterval(cleanupInactiveGames, CLEANUP_INTERVAL);\n\n    io.on('connection', (socket: GameSocket) => {\n        console.log('User connected');\n\n        socket.on('joinGame', (gameId: string, playerId: string) => {\n            try \n            {\n                if (!isValidGameID(gameId))\n                {\n                    throw new Error(`Invalid Game ID: ${gameId}`);\n                }\n\n                console.log(`user joined game ${gameId}`);\n    \n                if (!(playerId && uuidValidate(playerId) && (uuidVersion(playerId) === 4)))\n                {\n                    throw new Error(`Invalid Player ID: ${playerId}`);\n                }\n                \n                let game = null;\n                if(!games[gameId]) {\n                    throw new Error(`Can't find Game ID: ${gameId}`);\n                } else {\n                    game = games[gameId];\n                    console.log(`Game existed: ${gameId}`);\n                }\n\n                socket.gameId = gameId;\n\n                game.lastActivity = Date.now();\n\n                socket.join(gameId);\n                const player = game.serverGame.addPlayer({ \n                    id: playerId, \n                    name: \"Player\", \n                    playerType: PlayerType.Human\n                });\n\n                socket.player = player;\n\n                io.to(gameId).emit(\"showNotification\", {\n                    message: `שחקן/ית ${player.index + 1} התחבר/ה`\n                });\n\n                socket.emit('initBoard', {\n                    board: game.serverGame.board,\n                    player: Player.toJson(player),\n                    gameId: gameId,\n                    allPlayersJoined: game.serverGame.allPlayersJoined()\n                });\n\n                if (game.serverGame.allPlayersJoined())\n                {\n                    io.to(gameId).emit('gameUpdate', {\n                        board: null,\n                        currentPlayerIndex: game.serverGame.currentPlayer.index,\n                        moveDetails: null,\n                        swapDetails: null,\n                        points: JSON.stringify(Array.from(game.serverGame.getPoints().entries())),\n                        numTilesInBag: game.serverGame.bag.length\n                    });\n                }\n\n                if (game.serverGame.isGameOver())\n                {\n                    io.to(gameId).emit('gameOver', {\n                        winnerIndex: game.serverGame.getLeadingPlayer()\n                    });\n                }\n            }\n            catch (error)\n            {\n                console.log(`Error: ${error}`);\n                socket.emit('generalError', {\n                    error: error\n                });\n            }\n        });\n\n        socket.on('makeMove', (move: any) => {\n            try \n            {\n                const gameId = socket.gameId;\n                if (!gameId) {\n                    throw new Error(\"Game ID not found\");\n                }\n\n                console.log(`user made a move in game ${gameId}`, move);\n                const game = games[gameId];\n                if (!game) {\n                    throw new Error(`Game ${gameId} not found`);\n                }\n                                \n                if (socket.player !== game.serverGame.currentPlayer) {\n                    throw new Error(\"Not your turn\");\n                }\n\n                game.lastActivity = Date.now();\n\n                let tilePlacements: TilePlacement[] = move.map((tilePlacement: TilePlacement) => {\n                    return {tile: game.serverGame.bag.getTileById(Tile.fromJson(tilePlacement.tile).id), \n                                                                  r: tilePlacement.r, c: tilePlacement.c}\n                });\n                const moveDetails = game.serverGame.endTurnCallback(tilePlacements, false);\n\n                console.log(`End of turn in game ${gameId}`);\n\n                socket.emit('playerUpdate', {\n                    player: Player.toJson(socket.player)\n                });\n\n                // Broadcast changes\n                io.to(gameId).emit('gameUpdate', {\n                    board: game.serverGame.board,\n                    currentPlayerIndex: game.serverGame.currentPlayer.index,\n                    moveDetails: moveDetails,\n                    swapDetails: null,\n                    points: JSON.stringify(Array.from(game.serverGame.getPoints().entries())),\n                    numTilesInBag: game.serverGame.bag.length\n                });\n\n                if (game.serverGame.isGameOver())\n                {\n                    io.to(gameId).emit('gameOver', {\n                        winnerIndex: game.serverGame.getLeadingPlayer()\n                    });\n\n                    if (!game.isMarkedForDelete) {\n                        setTimeout(() => {\n                            console.log(`Removing game ${gameId} after game over`);\n                            if (gameId in games)\n                            {\n                                delete games[gameId];\n                            }\n                        }, CLEANUP_DELAY);\n                        game.isMarkedForDelete = true;\n                    }\n                }\n                \n            }\n            catch (err)\n            {\n                if (err instanceof UserError) \n                {\n                    socket.emit(\"showError\", {type: err.type, extraData: err.extraData});\n                }\n                console.log(`Error: ${err}`);\n            }\n        });\n\n        socket.on('swapTiles', (tiles: any) => {\n            // TODO: Code duplication with MakeMove\n            try \n            {\n                const gameId = socket.gameId;\n                if (!gameId) {\n                    throw new Error(\"Game ID not found\");\n                }\n\n                console.log(`user wants to swap tiles in game ${gameId}`, tiles);\n                const game = games[gameId];\n                if (!game) {\n                    throw new Error(`Game ${gameId} not found`);\n                }\n                                \n                if (socket.player !== game.serverGame.currentPlayer) {\n                    throw new Error(\"Not your turn\");\n                }\n\n                game.lastActivity = Date.now();\n\n                const swapDetails = game.serverGame.swapTiles(tiles.map((tile: Tile) => Tile.fromJson(tile)));  \n\n                console.log(`End of turn in game ${gameId}`);\n\n                socket.emit('playerUpdate', {\n                    player: Player.toJson(socket.player)\n                });\n\n                // Broadcast changes\n                io.to(gameId).emit('gameUpdate', {\n                    board: game.serverGame.board,\n                    currentPlayerIndex: game.serverGame.currentPlayer.index,\n                    moveDetails: null,\n                    swapDetails: swapDetails,\n                    points: JSON.stringify(Array.from(game.serverGame.getPoints().entries())),\n                    numTilesInBag: game.serverGame.bag.length\n                });\n\n                \n            }\n            catch (err)\n            {\n                if (err instanceof UserError) \n                {\n                    socket.emit(\"showError\", {type: err.type, extraData: err.extraData});\n                }\n                console.log(`Error: ${err}`);\n            }\n        });\n\n        socket.on('disconnect', () => {\n            try\n            {\n                console.log('user disconnected');\n                const gameId = socket.gameId;\n\n                if (gameId) \n                {\n                    const playerIndex = socket.player ? socket.player.index + 1 : \"\";\n                    io.to(gameId).emit(\"showNotification\", {\n                        message: `שחקן/ית ${playerIndex} התנתק/ה`\n                    });\n                }\n\n            }\n            catch (error)\n            {\n                console.log(`Error: ${error}`);\n            }\n        });\n    });\n}\n","/*\r\nThis code was ported from Python to Javascript based on reference code from:\r\nhttps://github.com/pytries/DAWG-Python/\r\n\r\nThe original code was licensed under MIT license:\r\n\r\n    Copyright (c) Mikhail Korobov, 2012\r\n\r\n    Permission is hereby granted, free of charge, to any person obtaining a copy\r\n    of this software and associated documentation files (the \"Software\"), to deal\r\n    in the Software without restriction, including without limitation the rights\r\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n    copies of the Software, and to permit persons to whom the Software is furnished\r\n    to do so, subject to the following conditions:\r\n\r\n    The above copyright notice and this permission notice shall be included in all\r\n    copies or substantial portions of the Software.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR\r\n    A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\r\n    CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\r\n    OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\nexport const PRECISION_MASK = 0xFFFFFFFF\r\n\r\nexport const OFFSET_MAX = 1 << 21\r\nexport const IS_LEAF_BIT = 1 << 31\r\nexport const HAS_LEAF_BIT = 1 << 8\r\nexport const EXTENSION_BIT = 1 << 9\r\n\r\n/**\r\n * Check if a unit has a leaf as a child or not.\r\n */\r\nexport function has_leaf(base : number, _mask=HAS_LEAF_BIT) : boolean\r\n{\r\n    return (base & _mask) ? true : false;\r\n}\r\n\r\n/**\r\n * Check if a unit corresponds to a leaf or not.\r\n */\r\nexport function value(base : number, _mask=~IS_LEAF_BIT & PRECISION_MASK) : number\r\n{\r\n    return base & _mask;\r\n}\r\n\r\n/**\r\n * Read a label with a leaf flag from a non-leaf unit.\r\n */\r\nexport function label(base : number, _mask=IS_LEAF_BIT | 0xFF) : number\r\n{\r\n    return base & _mask;\r\n}\r\n\r\n/**\r\n * Read an offset to child units from a non-leaf unit.\r\n */\r\nexport function offset(base : number) : number\r\n{\r\n    return ((base >> 10) << ((base & EXTENSION_BIT) >> 6)) & PRECISION_MASK;\r\n}","/*\r\nThis code was ported from Python to Javascript based on reference code from:\r\nhttps://github.com/pytries/DAWG-Python/\r\n\r\nThe original code was licensed under MIT license:\r\n\r\n    Copyright (c) Mikhail Korobov, 2012\r\n\r\n    Permission is hereby granted, free of charge, to any person obtaining a copy\r\n    of this software and associated documentation files (the \"Software\"), to deal\r\n    in the Software without restriction, including without limitation the rights\r\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n    copies of the Software, and to permit persons to whom the Software is furnished\r\n    to do so, subject to the following conditions:\r\n\r\n    The above copyright notice and this permission notice shall be included in all\r\n    copies or substantial portions of the Software.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR\r\n    A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\r\n    CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\r\n    OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\nimport * as units from './units.js';\r\n\r\n/**\r\n * Dictionary class for retrieval and binary I/O.\r\n */\r\nexport class Dictionary \r\n{\r\n    private _units : Uint32Array | null;\r\n    public ROOT : number;\r\n\r\n    constructor() \r\n    {\r\n        this._units = null;\r\n        this.ROOT = 0;\r\n    }\r\n\r\n    /**\r\n     * Checks if a given index is related to the end of a key.\r\n     */\r\n    has_value(index: number) : boolean\r\n    {\r\n        if ( this._units == null )\r\n        {\r\n            return false;\r\n        }\r\n        return units.has_leaf(this._units[index]);\r\n    }\r\n    \r\n    /**\r\n     * Gets a value from a given index.\r\n     */\r\n    value(index: number) : number\r\n    {\r\n        if (this._units == null)\r\n        {\r\n            throw \"Error: _units is null!\";\r\n        }\r\n\r\n        const offset = units.offset(this._units[index]);\r\n        const value_index = (index ^ offset) & units.PRECISION_MASK;\r\n        return units.value(this._units[value_index]);\r\n    }\r\n\r\n    /**\r\n     * Reads a dictionary from an input stream.\r\n     */\r\n    read(raw_buffer: ArrayBuffer) : void\r\n    {\r\n        let view = new DataView(raw_buffer);\r\n        let base_size = view.getUint32(0, true);\r\n        this._units = new Uint32Array(raw_buffer, 4, base_size);\r\n    }\r\n\r\n    /**\r\n     * Exact matching.\r\n     */\r\n    contains(key: Uint8Array) : boolean\r\n    {\r\n        const index = this.follow_bytes(key, this.ROOT);\r\n        if (index === null) \r\n        {\r\n            return false;\r\n        }\r\n        return this.has_value(index);\r\n    }\r\n\r\n    /**\r\n     * Exact matching (returns value)\r\n     */\r\n    find(key: Uint8Array) : number\r\n    {\r\n        const index = this.follow_bytes(key, this.ROOT);\r\n        if (index === null) {\r\n            return -1;\r\n        }\r\n        if (!this.has_value(index)) {\r\n            return -1;\r\n        }\r\n        return this.value(index);\r\n    }\r\n\r\n    /**\r\n     * Follows a transition\r\n     */\r\n    follow_char(label : number, index : number) : number | null\r\n    {\r\n        if (this._units == null)\r\n        {\r\n            throw \"Error: _units is null!\";\r\n        }\r\n\r\n        const offset = units.offset(this._units[index]);\r\n        const next_index = (index ^ offset ^ label) & units.PRECISION_MASK;\r\n\r\n        if (units.label(this._units[next_index]) != label) {\r\n            return null;\r\n        }\r\n\r\n        return next_index;\r\n    }\r\n\r\n    /**\r\n     * Follows transitions.\r\n     */\r\n    follow_bytes(s: Uint8Array, index: number) : number | null\r\n    {\r\n        let i : number | null = index;\r\n        for (let ch of s) {\r\n            i = this.follow_char(ch, i)\r\n            if (i === null) {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        return i;\r\n    }\r\n}\r\n\r\nexport class Guide \r\n{\r\n\r\n    private _units : Uint8Array | null;\r\n    public ROOT : number;\r\n    \r\n    constructor() \r\n    {\r\n        this._units = null;\r\n        this.ROOT = 0;\r\n    }\r\n\r\n    child(index : number) : number\r\n    {\r\n        if (this._units == null)\r\n        {\r\n            throw \"Can't use Guide before reading into it.\";\r\n        }\r\n        return this._units[index*2];\r\n    }\r\n\r\n    sibling(index : number) : number\r\n    {\r\n        if (this._units == null)\r\n        {\r\n            throw \"Can't use Guide before reading into it.\";\r\n        }\r\n\r\n        return this._units[index*2 + 1];\r\n    }\r\n\r\n    read(raw_buffer : ArrayBuffer) : void\r\n    {\r\n        let view = new DataView(raw_buffer);\r\n        let dict_size = view.getUint32(0, true);\r\n        let guide_offset = 4 + (dict_size * 4);\r\n        let base_size = view.getUint32(guide_offset, true);\r\n        this._units = new Uint8Array(raw_buffer, guide_offset + 4, base_size * 2);\r\n    }\r\n\r\n    size() : number\r\n    {\r\n        if (this._units == null)\r\n        {\r\n            throw \"Can't use Guide before reading into it.\";\r\n        }\r\n\r\n        return this._units.length;\r\n    }\r\n}\r\n\r\nexport class Completer \r\n{\r\n    private _dic : Dictionary;\r\n    private _guide : Guide;\r\n    private _last_index : number;\r\n    private _index_stack : number[];\r\n    private _parent_index : number;\r\n    private _sib_index : number | null;\r\n    public key : number[];\r\n    \r\n    constructor(dic: Dictionary, guide: Guide) \r\n    {\r\n        this._dic = dic;\r\n        this._guide = guide;\r\n        this._last_index = -1;\r\n        this._index_stack = [];\r\n        this._parent_index = -1;\r\n        this._sib_index = null;\r\n        this.key = [];\r\n    }\r\n\r\n    value() : number\r\n    {\r\n        return this._dic.value(this._last_index)\r\n    }\r\n\r\n    start(index: number, prefix: Uint8Array) \r\n    {\r\n        this.key = [...prefix];\r\n\r\n        if (this._guide.size()) \r\n        {\r\n            this._index_stack = [index];\r\n            this._last_index = this._dic.ROOT;\r\n        }\r\n        else \r\n        {\r\n            this._index_stack = [];\r\n        }\r\n    }\r\n\r\n    start_edges(index: number, prefix: Uint8Array) : boolean\r\n    {\r\n        this.key = [...prefix];\r\n        this._parent_index = index;\r\n        this._sib_index = null;\r\n        if (this._guide.size() > 0)\r\n        {\r\n            let child_label = this._guide.child(index);\r\n\r\n            if (child_label)\r\n            {\r\n                let next_index = this._dic.follow_char(child_label, index);\r\n                if (index != null)\r\n                {\r\n                    this._sib_index = next_index;\r\n                    this.key.push(child_label);\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    next_edge() : boolean\r\n    {\r\n        if (this._sib_index == null)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        let sibling_label = this._guide.sibling(this._sib_index);\r\n        this._sib_index = this._dic.follow_char(sibling_label, this._parent_index);\r\n        if (this._sib_index == null)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        this.key.pop();\r\n        this.key.push(sibling_label);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the next key\r\n     */\r\n    next() : boolean\r\n    {\r\n\r\n        if (this._index_stack.length === 0) \r\n        {\r\n            return false;\r\n        }\r\n\r\n        let index : number | null = this._index_stack[this._index_stack.length - 1];\r\n\r\n        if (this._last_index != this._dic.ROOT) \r\n        {\r\n\r\n            const child_label = this._guide.child(index);\r\n\r\n            if (child_label) \r\n            {\r\n                // Follows a transition to the first child.\r\n                index = this._follow(child_label, index);\r\n                if (index === null) \r\n                {\r\n                    return false;\r\n                }\r\n            }\r\n            else \r\n            {\r\n                while (true) \r\n                {\r\n                    let sibling_label = this._guide.sibling(index);\r\n                    // Moves to the previous node.\r\n                    if (this.key.length > 0) \r\n                    {\r\n                        this.key.pop();\r\n                    }\r\n\r\n                    this._index_stack.pop();\r\n                    if (this._index_stack.length === 0) \r\n                    {\r\n                        return false;\r\n                    }\r\n\r\n                    index = this._index_stack[this._index_stack.length - 1];\r\n                    if (sibling_label) \r\n                    {\r\n                        // Follows a transition to the next sibling.\r\n                        index = this._follow(sibling_label, index);\r\n                        if (index === null) \r\n                        {\r\n                            return false;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return this._find_terminal(index);\r\n    }\r\n\r\n    _follow(label : number, index : number) : number | null\r\n    {\r\n        const next_index = this._dic.follow_char(label, index);\r\n        if (next_index === null) {\r\n            return null;\r\n        }\r\n\r\n        this.key.push(label);\r\n        this._index_stack.push(next_index);\r\n        return next_index;\r\n    }\r\n\r\n    _find_terminal(index : number) : boolean\r\n    {\r\n        while (!this._dic.has_value(index)) {\r\n            let label = this._guide.child(index);\r\n\r\n            let i : number | null = this._dic.follow_char(label, index);\r\n            if (index === null) {\r\n                return false;\r\n            }\r\n            index = i!;\r\n\r\n            this.key.push(label);\r\n            this._index_stack.push(index);\r\n        }\r\n\r\n        this._last_index = index;\r\n        return true;\r\n    }\r\n}","/*\nThis code was ported from Python to Javascript based on reference code from:\nhttps://github.com/pytries/DAWG-Python/\n\nThe original code was licensed under MIT license:\n\n    Copyright (c) Mikhail Korobov, 2012\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is furnished\n    to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR\n    A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n    CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n    OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport { Completer, Dictionary, Guide } from './wrapper.js';\n\nexport class CompletionDAWG \n{\n\n    private dct : Dictionary | null;\n    private guide : Guide | null;\n\n    constructor() \n    {\n        this.dct = null;\n        this.guide = null;\n    }\n\n    keys(prefix = \"\") : string[]\n    {\n        const encoder = new TextEncoder();\n        const decoder = new TextDecoder(\"utf-8\");\n        const b_prefix = encoder.encode(prefix);\n        const res : string[] = [];\n\n        if ( (this.dct == null) || (this.guide == null) )\n        {\n            throw \"Dictionary must be loaded first!\";\n        }\n\n        const index = this.dct.follow_bytes(b_prefix, this.dct.ROOT);\n        if (index === null) \n        {\n            return res;\n        }\n\n        const completer = new Completer(this.dct, this.guide);\n        completer.start(index, b_prefix);\n\n        while (completer.next()) \n        {\n            let key = decoder.decode(new Uint8Array(completer.key));\n            res.push(key);\n        }\n\n        return res;\n    }\n\n    edges(prefix = \"\") : string[]\n    {\n        const encoder = new TextEncoder();\n        const decoder = new TextDecoder(\"utf-8\");\n        const b_prefix = encoder.encode(prefix);\n        const res : string[] = [];\n\n        if ( (this.dct == null) || (this.guide == null) )\n        {\n            throw \"Dictionary must be loaded first!\";\n        }\n\n        const index = this.dct.follow_bytes(b_prefix, this.dct.ROOT);\n        if (index === null) \n        {\n            return res;\n        }\n\n        const completer = new Completer(this.dct, this.guide);\n        if (!completer.start_edges(index, b_prefix))\n        {\n            return res;\n        }\n\n        let key = decoder.decode(new Uint8Array(completer.key));\n        res.push(key.slice(-1));\n\n        while (completer.next_edge()) \n        {\n            key = decoder.decode(new Uint8Array(completer.key));\n            res.push(key.slice(-1));\n        }\n\n        return res;\n    }\n\n    contains(key: string) : boolean\n    {\n        const encoder = new TextEncoder();\n        const b_key = encoder.encode(key);\n\n        if ( (this.dct == null) || (this.guide == null) )\n        {\n            throw \"Dictionary must be loaded first!\";\n        }\n\n        return this.dct.contains(b_key);\n    }\n\n    load(raw_bytes : ArrayBuffer) \n    {\n        this.dct = new Dictionary();\n        this.guide = new Guide();\n\n        this.dct.read(raw_bytes);\n        this.guide.read(raw_bytes);\n\n        return this;\n    }\n}","\r\n\r\nimport { CompletionDAWG } from \"./dawg/dawgs.js\";\r\nimport {Languages} from '../../shared/src/Constants.js'\r\nimport { promises as fs } from 'fs';\r\nimport * as path from 'path';\r\n\r\n/**\r\n * Dictionary class represents the dictionary.\r\n * @class\r\n */\r\nexport default class Dictionary \r\n{ \r\n    private dawg : CompletionDAWG | null;\r\n    private translateMapping : Record<string, string>;\r\n    private reverseTranslateMapping : Record<string, string>;\r\n    private _alphabet : Set<string>;\r\n\r\n    /**\r\n     * Constructor for Dictionary class.\r\n     */\r\n    constructor()\r\n    {\r\n        this.dawg = null;\r\n        this.translateMapping = {\"\": \"\"};\r\n        this.reverseTranslateMapping = {\"\": \"\"};\r\n        this._alphabet = new Set<string>();\r\n    }\r\n\r\n    /**\r\n     * Initializes the dictionary by loading the word list.\r\n     */\r\n    async init(basePath: string): Promise<void> {\r\n        const configPath = path.join(basePath, 'wordlists', 'config.json');\r\n        const configRaw = await fs.readFile(configPath, 'utf8');\r\n        const config = JSON.parse(configRaw);\r\n\r\n        this.translateMapping = config[\"translate_mapping\"] as Record<string, string>;\r\n        this.reverseTranslateMapping = config[\"reverse_translate_mapping\"] as Record<string, string>;\r\n\r\n        for (const key in this.translateMapping) {\r\n            this._alphabet.add(key);\r\n        }\r\n\r\n        const dirName = \"hspell\";\r\n        const wordlistConfig = config[\"wordlists\"][dirName];\r\n\r\n        if (wordlistConfig[\"type\"] !== \"dawg\") {\r\n            throw new Error(`Unsupported file type: ${wordlistConfig[\"type\"]}`);\r\n        }\r\n\r\n        const dictPath = path.join(basePath, 'wordlists', dirName, wordlistConfig[\"filename\"]);\r\n\r\n        let rawDictionary: ArrayBuffer;\r\n        try {\r\n            const buffer = await fs.readFile(dictPath);\r\n            rawDictionary = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\r\n        } catch (err: any) {\r\n            if (err.code === 'ENOENT') {\r\n                console.log(\"Can't find database\");\r\n            }\r\n            throw new Error(`An error has occurred while loading the dictionary: ${err.message}`);\r\n        }\r\n\r\n        this.dawg = new CompletionDAWG();\r\n\r\n        const startTime = performance.now();\r\n        this.dawg.load(rawDictionary);\r\n        const endTime = performance.now();\r\n\r\n        console.log(`Loaded DAWG database in ${endTime - startTime} milliseconds`);\r\n    }\r\n\r\n    /*\r\n     * Words in the dictionary might be encoded in a different encoding.\r\n     * For example, the Hebrew dictionary is encoded with English characters.\r\n     * This function translates the word in from its original encoding (e.g Hebrew)\r\n     * to the encoding used in the raw dictionary representation (e.g. English characters).\r\n     */\r\n    private directTranslation(word: string) : string\r\n    {        \r\n        // Hebrew characters to English characters\r\n        return word.replace(/(\\?|[\\u0590-\\u05fe])/g, m => this.translateMapping[m]);\r\n    }\r\n\r\n    /*\r\n     * Performs the reverse translation for directTranslation().\r\n     */\r\n    private reverseTranslation(word: string) : string\r\n    {\r\n        return word.replace(/(\\?|[a-zA-Z])/g, m => this.reverseTranslateMapping[m]);\r\n    }\r\n\r\n    /**\r\n     * Checks if a word is in the dictionary.\r\n     * @param word - The word to check.\r\n     * @returns True if the word is in the dictionary, false otherwise.\r\n     */\r\n    public contains(word: string) : boolean\r\n    {\r\n        if (this.dawg == null)\r\n        {\r\n            throw new Error(\"Dictionary must be loaded before using it\");\r\n        }\r\n\r\n        return this.dawg.contains(this.directTranslation(word) + \"\\r\");\r\n    }\r\n\r\n    /**\r\n     * Returns all words in the dictionary that start with a given prefix.\r\n     * @param prefix - The prefix to search for.\r\n     * @returns A set of the next letter for all words in the dictionary that start with the given prefix.\r\n     */\r\n    public edges(prefix: string) : Set<string>\r\n    {\r\n        if (this.dawg == null)\r\n        {\r\n            throw new Error(\"Dictionary must be loaded before using it\");\r\n        }\r\n\r\n        const res = new Set<string>(this.dawg.edges(this.directTranslation(prefix)).map((x: string) => this.reverseTranslation(x)));\r\n        res.delete(\"\\r\");\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Getter for the alphabet of the dictionary.\r\n     * @returns A set containing all characters in the alphabet of the dictionary.\r\n     */\r\n    get alphabet() : Set<string>\r\n    {\r\n        return new Set<string>(this._alphabet);\r\n    }\r\n}"],"mappings":"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","names":["path","value","value","MoveDetails","offset","label","Dictionary","Dictionary","path"]}